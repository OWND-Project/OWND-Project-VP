import { describe, it } from "mocha";
import { expect } from "chai";
import {
  generateEphemeralKeyPair,
  decryptJWE,
} from "../../src/helpers/jwt-helper.js";
import { CompactEncrypt, importJWK } from "jose";

describe("JWT Helper - JWE Encryption", () => {
  describe("#generateEphemeralKeyPair", () => {
    it("should generate ECDH-ES key pair with P-256 curve", async () => {
      const { publicJwk, privateJwk, kid } = await generateEphemeralKeyPair();

      expect(publicJwk.kty).to.equal("EC");
      expect(publicJwk.crv).to.equal("P-256");
      expect(publicJwk.use).to.equal("enc");
      expect(publicJwk.alg).to.equal("ECDH-ES");
      expect(publicJwk.kid).to.equal(kid);
      expect(publicJwk.x).to.exist;
      expect(publicJwk.y).to.exist;

      expect(privateJwk.kty).to.equal("EC");
      expect(privateJwk.crv).to.equal("P-256");
      expect(privateJwk.kid).to.equal(kid);
      expect(privateJwk.d).to.exist;
    });
  });

  describe("#decryptJWE", () => {
    it("should decrypt JWE encrypted with ECDH-ES + A128GCM", async () => {
      // Verifier (Response Endpoint) generates static key pair
      const verifierKeys = await generateEphemeralKeyPair();

      const payload = {
        vp_token: {
          test_credential: ["eyJhbGci..."],
        },
      };

      // Wallet encrypts using Verifier's public key
      // Note: ECDH-ES uses TWO different key pairs:
      // 1. Verifier's static key pair (generated above, public key shared with Wallet)
      // 2. Wallet's ephemeral key pair (automatically generated by CompactEncrypt)
      //
      // Encryption process (performed by CompactEncrypt):
      // - Generates Wallet's ephemeral key pair
      // - Performs ECDH: Wallet's ephemeral private key + Verifier's public key -> shared secret
      // - Derives A128GCM encryption key from shared secret
      // - Encrypts payload with A128GCM
      // - Includes Wallet's ephemeral public key in JWE header (epk field)
      const verifierPublicKey = await importJWK(verifierKeys.publicJwk, "ECDH-ES");

      const jwe = await new CompactEncrypt(
        new TextEncoder().encode(JSON.stringify(payload)),
      )
        .setProtectedHeader({
          alg: "ECDH-ES",
          enc: "A128GCM",
          kid: verifierKeys.publicJwk.kid,
        })
        .encrypt(verifierPublicKey);

      // Verifier decrypts using its private key
      // Decryption process (performed by decryptJWE):
      // - Extracts Wallet's ephemeral public key from JWE header (epk field)
      // - Performs ECDH: Verifier's private key + Wallet's ephemeral public key -> same shared secret
      // - Derives same A128GCM encryption key
      // - Decrypts and verifies authentication tag
      const decrypted = await decryptJWE(jwe, verifierKeys.privateJwk);

      expect(decrypted).to.deep.equal(payload);
    });

    it("should reject JWE with unsupported algorithm (RSA-OAEP)", async () => {
      const { privateJwk } = await generateEphemeralKeyPair();

      // JWE with wrong algorithm in protected header
      const fakeJwe =
        "eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkExMjhHQ00ifQ..invalid.invalid.invalid";

      try {
        await decryptJWE(fakeJwe, privateJwk);
        expect.fail("Should have thrown an error");
      } catch (error: any) {
        expect(error.message).to.include("Unsupported JWE algorithm");
        expect(error.message).to.include("RSA-OAEP");
      }
    });

    it("should reject JWE with unsupported encryption method (A256GCM)", async () => {
      const { publicJwk, privateJwk } = await generateEphemeralKeyPair();
      const publicKey = await importJWK(publicJwk, "ECDH-ES");

      // Encrypt with A256GCM instead of A128GCM
      const jwe = await new CompactEncrypt(
        new TextEncoder().encode(JSON.stringify({ test: "data" })),
      )
        .setProtectedHeader({
          alg: "ECDH-ES",
          enc: "A256GCM",
          kid: publicJwk.kid,
        })
        .encrypt(publicKey);

      try {
        await decryptJWE(jwe, privateJwk);
        expect.fail("Should have thrown an error");
      } catch (error: any) {
        expect(error.message).to.include("Unsupported JWE encryption");
        expect(error.message).to.include("A256GCM");
      }
    });

    it("should detect tampering via authentication tag verification", async () => {
      const { publicJwk, privateJwk } = await generateEphemeralKeyPair();
      const publicKey = await importJWK(publicJwk, "ECDH-ES");

      const payload = { vp_token: { test_credential: ["original"] } };
      const jwe = await new CompactEncrypt(
        new TextEncoder().encode(JSON.stringify(payload)),
      )
        .setProtectedHeader({
          alg: "ECDH-ES",
          enc: "A128GCM",
          kid: publicJwk.kid,
        })
        .encrypt(publicKey);

      // Tamper with the JWE (modify ciphertext part)
      const parts = jwe.split(".");
      const tamperedCiphertext = parts[3].slice(0, -4) + "XXXX";
      const tamperedJwe = [parts[0], parts[1], parts[2], tamperedCiphertext, parts[4]].join(".");

      try {
        await decryptJWE(tamperedJwe, privateJwk);
        expect.fail("Should have thrown an error for tampered JWE");
      } catch (error: any) {
        // jose library throws JWEDecryptionFailed for authentication tag mismatch
        expect(error.code || error.message).to.exist;
      }
    });

    it("should verify ECDH key exchange works correctly", async () => {
      // Generate two different key pairs
      const verifierKeys = await generateEphemeralKeyPair();
      const wrongKeys = await generateEphemeralKeyPair();

      const payload = { vp_token: { test: "data" } };
      const publicKey = await importJWK(verifierKeys.publicJwk, "ECDH-ES");
      const jwe = await new CompactEncrypt(
        new TextEncoder().encode(JSON.stringify(payload)),
      )
        .setProtectedHeader({
          alg: "ECDH-ES",
          enc: "A128GCM",
          kid: verifierKeys.publicJwk.kid,
        })
        .encrypt(publicKey);

      // Correct key should decrypt successfully
      const decrypted = await decryptJWE(jwe, verifierKeys.privateJwk);
      expect(decrypted).to.deep.equal(payload);

      // Wrong key should fail
      try {
        await decryptJWE(jwe, wrongKeys.privateJwk);
        expect.fail("Should have failed with wrong private key");
      } catch (error: any) {
        // Expected: decryption fails with wrong key
        expect(error).to.exist;
      }
    });
  });
});
